<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Graph Protocol RFCs and Engineering Plans</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="assets/mermaid.css">
        
        <link rel="stylesheet" href="assets/custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="expanded "><a href="rfcs/index.html"><strong aria-hidden="true">2.</strong> RFCs</a></li><li><ol class="section"><li class="expanded "><a href="rfcs/approved.html"><strong aria-hidden="true">2.1.</strong> Approved RFCs</a></li><li><ol class="section"><li class="expanded "><a href="rfcs/0002-ethereum-tracing-cache.html"><strong aria-hidden="true">2.1.1.</strong> RFC-0002: Ethereum Tracing Cache</a></li></ol></li><li class="expanded "><a href="rfcs/obsolete.html"><strong aria-hidden="true">2.2.</strong> Obsolete RFCs</a></li><li class="expanded "><a href="rfcs/rejected.html"><strong aria-hidden="true">2.3.</strong> Rejected RFCs</a></li></ol></li><li class="expanded "><a href="engineering-plans/index.html"><strong aria-hidden="true">3.</strong> Engineering Plans</a></li><li><ol class="section"><li class="expanded "><a href="engineering-plans/approved.html"><strong aria-hidden="true">3.1.</strong> Approved Plans</a></li><li><ol class="section"><li class="expanded "><a href="engineering-plans/0001-graphql-query-prefetching.html"><strong aria-hidden="true">3.1.1.</strong> PLAN-0001: GraphQL Query Prefetching</a></li><li class="expanded "><a href="engineering-plans/0003-remove-jsonb-storage.html"><strong aria-hidden="true">3.1.2.</strong> PLAN-0003: Remove JSONB Storage</a></li></ol></li><li class="expanded "><a href="engineering-plans/obsolete.html"><strong aria-hidden="true">3.2.</strong> Obsolete Plans</a></li><li class="expanded "><a href="engineering-plans/rejected.html"><strong aria-hidden="true">3.3.</strong> Rejected Plans</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Graph Protocol RFCs and Engineering Plans</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This repository / book describes the process for proposing changes to Graph
Protocol in the form of <a href="./rfcs/index.html">RFCs</a> and <a href="./engineering-plans/index.html">Engineering
Plans</a>.</p>
<p>It also includes all approved, rejected and obsolete RFCs and Engineering Plans.
For more details, see the following pages:</p>
<ul>
<li><a href="./rfcs/index.html">RFCs</a></li>
<li><a href="./engineering-plans/index.html">Engineering Plans</a></li>
</ul>
<h1><a class="header" href="#rfcs" id="rfcs">RFCs</a></h1>
<h2><a class="header" href="#what-is-an-rfc" id="what-is-an-rfc">What is an RFC?</a></h2>
<p>An RFC describes a change to Graph Protocol, for example a new feature. Any
substantial change goes through the RFC process, where the change is described
in an RFC, is proposed a pull request to the <code>rfcs</code> repository, is reviewed,
currently by the core team, and ultimately is either either approved or
rejected.</p>
<h2><a class="header" href="#rfc-process" id="rfc-process">RFC process</a></h2>
<h3><a class="header" href="#1-create-a-new-rfc" id="1-create-a-new-rfc">1. Create a new RFC</a></h3>
<p>RFCs are numbered, starting at <code>0001</code>. To create a new RFC, create a new branch
of the <code>rfcs</code> repository. Check the existing RFCs to identify the next number to
use. Then, copy the <a href="https://github.com/graphprotocol/rfcs/blob/master/rfcs/0000-template.md">RFC
template</a>
to a new file in the <code>rfcs/</code> directory. For example:</p>
<pre><code class="language-sh">cp rfcs/0000-template.md rfcs/0015-fulltext-search.md
</code></pre>
<p>Write the RFC, commit it to the branch and open a <a href="https://github.com/graphprotocol/rfcs/pulls">pull
request</a> in the <code>rfcs</code> repository.</p>
<p>In addition to the RFC itself, the pull request must include the following
changes:</p>
<ul>
<li>a link to the RFC on the <a href="rfcs/./approved.html">Approved RFCs</a> page, and</li>
<li>a link to the RFC under <code>Approved RFCs</code> in <code>SUMMARY.md</code>.</li>
</ul>
<h3><a class="header" href="#2-rfc-review" id="2-rfc-review">2. RFC review</a></h3>
<p>After an RFC has been submitted through a pull request, it is being reviewed. At
the time of writing, every RFC needs to be approved by</p>
<ul>
<li>at least one Graph Protocol founder, and</li>
<li>at least one member of the core development team.</li>
</ul>
<h3><a class="header" href="#3-rfc-approval" id="3-rfc-approval">3. RFC approval</a></h3>
<p>Once an RFC is approved, the RFC meta data (see the
<a href="https://github.com/graphprotocol/rfcs/blob/master/rfcs/0000-template.md">template</a>)
is updated and the pull request is merged by the original author or a Graph
Protocol team member.</p>
<h1><a class="header" href="#approved-rfcs" id="approved-rfcs">Approved RFCs</a></h1>
<ul>
<li><a href="rfcs/./0002-ethereum-tracing-cache.html">RFC-0002: Ethereum Tracing Cache</a></li>
</ul>
<h1><a class="header" href="#rfc-0002-ethereum-tracing-cache" id="rfc-0002-ethereum-tracing-cache">RFC-0002: Ethereum Tracing Cache</a></h1>
<dl>
  <dt>Author</dt>
  <dd>Zac Burns</dd>
<dt>RFC pull request</dt>
  <dd><a href="https://github.com/graphprotocol/rfcs/pull/4">https://github.com/graphprotocol/rfcs/pull/4</a></dd>
<dt>Obsoletes (if applicable)</dt>
  <dd>None</dd>
<dt>Date of submission</dt>
  <dd>2019-12-13</dd>
<dt>Date of approval</dt>
  <dd>2019-12-20</dd>
<dt>Approved by</dt>
  <dd>Jannis Pohlmann</dd>
</dl>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>This RFC proposes the creation of a local Ethereum tracing cache to speed up indexing of subgraphs which use block and/or call handlers.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>When indexing a subgraph that uses block and/or call handlers, it is necessary to extract calls from the trace of each block that a Graph Node indexes. It is expensive to acquire and process traces from Ethereum nodes in both money and time.</p>
<p>When developing a subgraph it is common to make changes and deploy those changes to a production Graph Node for testing. Each time a change is deployed, the Graph Node must re-sync the subgraph using the same traces that were used for the previous sync of the subgraph. The cost of acquiring the traces each time a change is deployed impacts a subgraph developer's ability to iterate and test quickly.</p>
<h2><a class="header" href="#urgency" id="urgency">Urgency</a></h2>
<p>None</p>
<h2><a class="header" href="#terminology" id="terminology">Terminology</a></h2>
<p><em>Ethereum cache</em>: The new API proposed here.</p>
<h2><a class="header" href="#detailed-design" id="detailed-design">Detailed Design</a></h2>
<p>There is an existing <code>EthereumCallCache</code> for caching <code>eth_call</code> built into Graph Node today. This cache will be extended to support traces, and renamed to <code>EthereumCache</code>.</p>
<h2><a class="header" href="#compatibility" id="compatibility">Compatibility</a></h2>
<p>This change is backwards compatible. Existing code can continue to use the parity tracing API. Because the cache is local, each indexing node may delete the cache should the format or implementation of caching change. In this case of invalidated cache the code will fall back to existing methods for retrieving a trace and repopulating the cache.</p>
<h2><a class="header" href="#drawbacks-and-risks" id="drawbacks-and-risks">Drawbacks and Risks</a></h2>
<p>Subgraphs which are not being actively developed will incur the overhead for storing traces, but will not ever reap the benefits of ever reading them back from the cache.</p>
<p>If this drawback is significant, it may be necessary to extend <code>EthereumCache</code> to provide a custom score for cache invalidation other than the current date. For example, <code>trace_filter</code> calls could be invalidated based on the latest update time for a subgraph requiring the trace. It is expected that a subgraph which has been updated recently is more likely to be updated again soon then a subgraph which has not been recently updated.</p>
<h2><a class="header" href="#alternatives" id="alternatives">Alternatives</a></h2>
<p>None</p>
<h2><a class="header" href="#open-questions" id="open-questions">Open Questions</a></h2>
<p>None</p>
<h1><a class="header" href="#obsolete-rfcs" id="obsolete-rfcs">Obsolete RFCs</a></h1>
<p>Obsolete RFCs are moved to the <code>rfcs/obsolete</code> directory in the <code>rfcs</code>
repository. They are listed below for reference.</p>
<ul>
<li>No RFCs have been obsoleted yet.</li>
</ul>
<h1><a class="header" href="#rejected-rfcs" id="rejected-rfcs">Rejected RFCs</a></h1>
<p>Rejected RFCs can be found by filtering open and closed pull requests by those
that are labeled with <code>rejected</code>. This list can be <a href="https://github.com/graphprotocol/rfcs/issues?q=label:rfc+label:rejected">found
here</a>.</p>
<h1><a class="header" href="#engineering-plans" id="engineering-plans">Engineering Plans</a></h1>
<h2><a class="header" href="#what-is-an-engineering-plan" id="what-is-an-engineering-plan">What is an Engineering Plan?</a></h2>
<p>Engineering Plans are plans to turn an <a href="engineering-plans/../rfcs/index.html">RFC</a> into an
implementation in the core Graph Protocol tools like Graph Node, Graph CLI and
Graph TS. Every substantial development effort that follows an RFC is planned in
the form of an Engineering Plan.</p>
<h2><a class="header" href="#engineering-plan-process" id="engineering-plan-process">Engineering Plan process</a></h2>
<h3><a class="header" href="#1-create-a-new-engineering-plan" id="1-create-a-new-engineering-plan">1. Create a new Engineering Plan</a></h3>
<p>Like RFCs, Engineering Plans are numbered, starting at <code>0001</code>. To create a new
plan, create a new branch of the <code>rfcs</code> repository. Check the existing plans to
identify the next number to use. Then, copy the <a href="https://github.com/graphprotocol/rfcs/blob/master/engineering-plans/0000-template.md">Engineering Plan
template</a>
to a new file in the <code>engineering-plans/</code> directory. For example:</p>
<pre><code class="language-sh">cp engineering-plans/0000-template.md engineering-plans/0015-fulltext-search.md
</code></pre>
<p>Write the Engineering Plan, commit it to the branch and open a <a href="https://github.com/graphprotocol/rfcs/pulls">pull
request</a> in the <code>rfcs</code> repository.</p>
<p>In addition to the Engineering Plan itself, the pull request must include the
following changes:</p>
<ul>
<li>a link to the Engineering Plan on the <a href="engineering-plans/./approved.html">Approved Engineering Plans</a> page, and</li>
<li>a link to the Engineering Plan under <code>Approved Engineering Plans</code> in <code>SUMMARY.md</code>.</li>
</ul>
<h3><a class="header" href="#2-engineering-plan-review" id="2-engineering-plan-review">2. Engineering Plan review</a></h3>
<p>After an Engineering Plan has been submitted through a pull request, it is being
reviewed. At the time of writing, every Engineering Plan needs to be approved by</p>
<ul>
<li>the Tech Lead, and</li>
<li>at least one member of the core development team.</li>
</ul>
<h3><a class="header" href="#3-engineering-plan-approval" id="3-engineering-plan-approval">3. Engineering Plan approval</a></h3>
<p>Once an Engineering Plan is approved, the Engineering Plan meta data (see the
<a href="https://github.com/graphprotocol/rfcs/blob/master/engineering-plans/0000-template.md">template</a>)
is updated and the pull request is merged by the original author or a Graph
Protocol team member.</p>
<h1><a class="header" href="#approved-engineering-plans" id="approved-engineering-plans">Approved Engineering Plans</a></h1>
<ul>
<li><a href="engineering-plans/./0001-graphql-query-prefetching.html">PLAN-0001: GraphQL Query Prefetching</a></li>
<li><a href="engineering-plans/./0003-remove-jsonb-storage.html">PLAN-0003: Remove JSONB Storage</a></li>
</ul>
<h1><a class="header" href="#plan-0001-graphql-query-prefetching" id="plan-0001-graphql-query-prefetching">PLAN-0001: GraphQL Query Prefetching</a></h1>
<dl>
  <dt>Author</dt>
  <dd>David Lutterkort</dd>
<dt>Implements</dt>
<dd>No RFC - no user visible changes</dd>
<dt>Engineering Plan pull request</dt>
<dd><a href="engineering-plans/<https://github.com/graphprotocol/rfcs/pull/2>">https://github.com/graphprotocol/rfcs/pull/2</a></dd>
<dt>Date of submission</dt>
<dd>2019-11-27</dd>
<dt>Date of approval</dt>
<dd>2019-12-10</dd>
<dt>Approved by</dt>
  <dd>Jannis Pohlmann, Leo Yvens</dd>
</dl>
<p>This is not really a plan as it was written and discussed before we adopted
the RFC process, but contains important implementation detail of how we
process GraphQL queries.</p>
<h2><a class="header" href="#contents" id="contents">Contents</a></h2>
<ul>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#implementation-details-for-prefetch-queries">Implementation Details for prefetch queries</a>
<ul>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#goal">Goal</a></li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#handling-firstskip">Handling first/skip</a></li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#handling-interfaces">Handling interfaces</a></li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#handling-parentchild-relationships">Handling parent/child relationships</a>
<ul>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#type-a">Type A</a></li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#type-b">Type B</a></li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#type-c">Type C</a></li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#type-d">Type D</a></li>
</ul>
</li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#putting-it-all-together">Putting it all together</a></li>
</ul>
</li>
<li><a href="engineering-plans/0001-graphql-query-prefetching.html#boring-list-of-possible-graphql-models">Boring list of possible GraphQL models</a></li>
</ul>
<h2><a class="header" href="#implementation-details-for-prefetch-queries" id="implementation-details-for-prefetch-queries">Implementation Details for prefetch queries</a></h2>
<h3><a class="header" href="#goal" id="goal">Goal</a></h3>
<p>For a GraphQL query of the form</p>
<pre><code class="language-graphql">query {
  parents(filter) {
    id
    children(filter) {
      id
    }
  }
}
</code></pre>
<p>we want to generate only two SQL queries: one to get the parents, and one
to get the children for all those parents. The fact that <code>children</code> is
nested under <code>parents</code> requires that we add a filter to the <code>children</code>
query that restricts children to those that are related to the parents we
fetched in the first query to get the parents. How exactly we filter the
<code>children</code> query depends on how the relationship between parents and
children is modeled in the GraphQL schema, and on whether one (or both) of
the types involved are interfaces.</p>
<p>The rest of this writeup is concerned with how to generate the query for
<code>children</code>, assuming we already retrieved the list of all parents.</p>
<p>The bulk of the implementation of this feature can be found in
<code>graphql/src/store/prefetch.rs</code>, <code>store/postgres/src/jsonb_queries.rs</code>, and
<code>store/postgres/src/relational_queries.rs</code></p>
<h3><a class="header" href="#handling-firstskip" id="handling-firstskip">Handling first/skip</a></h3>
<p>We never get all the <code>children</code> for a parent; instead we always have a
<code>first</code> and <code>skip</code> argument in the children filter. Those arguments need to
be applied to each parent individually by ranking the children for each
parent according to the order defined by the <code>children</code> query. If the same
child matches multiple parents, we need to make sure that it is considered
separately for each parent as it might appear at different ranks for
different parents. In SQL, we use the <code>rank()</code> window function for this:</p>
<pre><code class="language-sql">select *
  from (
    select c.*,
           rank() over (partition by parent_id order by ...) as pos
      from (query to get children) c)
 where pos &gt;= skip and pos &lt; skip + first
</code></pre>
<h3><a class="header" href="#handling-interfaces" id="handling-interfaces">Handling interfaces</a></h3>
<p>If <code>parents</code> or <code>children</code> (or both) are interfaces, we resolve the
interfaces into the concrete types implementing them, produce a query for
each combination of parent/child concrete type and combine those queries
via <code>union all</code>.</p>
<p>Since implementations of the same interface will generally differ in the schema
they use, we can not form a <code>union all</code> of all the data in the tables for
these concrete types, but have to first query only attributes that we know
will be common to all entities implementing the interface, most notably the
<code>vid</code> (a unique identifier that identifies the precise version of an
entity), and then later fill in the details of each entity by converting it
directly to JSON.</p>
<p>That means that when we deal with children that are an interface, we will
first select only the following columns (where exactly they come from
depends on how the parent/child relationship is modeled)</p>
<pre><code class="language-sql">select '{__typename}' as entity, c.vid, c.id, parent_id
</code></pre>
<p>and form the <code>union all</code> of these queries. We then use that union to rank
children as described above.</p>
<h3><a class="header" href="#handling-parentchild-relationships" id="handling-parentchild-relationships">Handling parent/child relationships</a></h3>
<p>How we get the children for a set of parents depends on how the
relationship between the two is modeled. The interesting parameters there
are whether parents store a list or a single child, and whether that field
is derived, together with the same for children.</p>
<p>There are a total of 16 combinations of these four boolean variables; four
of them, when both parent and child derive their fields, are not
permissible. It also doesn't matter whether the child derives its parent
field: when the parent field is not derived, we need to use that since that
is the only place that contains the parent -&gt; child relationship. When the
parent field is derived, the child field can not be a derived field.</p>
<p>That leaves us with the following combinations of whether the parent and
child store a list or a scalar value, and whether the parent is derived:</p>
<p>For details on the GraphQL schema for each row in this table, see the
section at the end. The <code>Join cond</code> indicates how we can find the children
for a given parent. There are four different join conditions in this table.</p>
<p>When we query children, we need to have the id of the parent that child is
related to (and list the child multiple times if it is related to multiple
parents) since that is the field by which we window and rank children.</p>
<p>For join conditions of type C and D, the id of the parent is not stored in
the child, which means we need to join with the <code>parents</code> table.</p>
<p>Let's work out the details of these queries; the implementation uses
<code>struct EntityLink</code> in <code>graph/src/components/store.rs</code> to distinguish
between the different types of joins and queries.</p>
<table><thead><tr><th>Case</th><th>Parent list?</th><th>Parent derived?</th><th>Child list?</th><th>Join cond</th><th>Type</th></tr></thead><tbody>
<tr><td>1</td><td>TRUE</td><td>TRUE</td><td>TRUE</td><td>child.parents ∋ parent.id</td><td>A</td></tr>
<tr><td>2</td><td>FALSE</td><td>TRUE</td><td>TRUE</td><td>child.parents ∋ parent.id</td><td>A</td></tr>
<tr><td>3</td><td>TRUE</td><td>TRUE</td><td>FALSE</td><td>child.parent = parent.id</td><td>B</td></tr>
<tr><td>4</td><td>FALSE</td><td>TRUE</td><td>FALSE</td><td>child.parent = parent.id</td><td>B</td></tr>
<tr><td>5</td><td>TRUE</td><td>FALSE</td><td>TRUE</td><td>child.id ∈ parent.children</td><td>C</td></tr>
<tr><td>6</td><td>TRUE</td><td>FALSE</td><td>FALSE</td><td>child.id ∈ parent.children</td><td>C</td></tr>
<tr><td>7</td><td>FALSE</td><td>FALSE</td><td>TRUE</td><td>child.id = parent.child</td><td>D</td></tr>
<tr><td>8</td><td>FALSE</td><td>FALSE</td><td>FALSE</td><td>child.id = parent.child</td><td>D</td></tr>
</tbody></table>
<h4><a class="header" href="#type-a" id="type-a">Type A</a></h4>
<p>Use when parent is derived and child is a list</p>
<pre><code class="language-sql">select c.*, parent_id
 from {children} c join lateral unnest(c.{parent_field}) parent_id
where parent_id = any($parent_ids)
</code></pre>
<p>Data needed to generate:</p>
<ul>
<li>children: name of child table</li>
<li>parent_ids: list of parent ids</li>
<li>parent_field: name of parents field (array) in child table</li>
</ul>
<p>The implementation uses a <code>EntityLink::Direct</code> for joins of this type.</p>
<h4><a class="header" href="#type-b" id="type-b">Type B</a></h4>
<p>Use when parent is derived and child is not a list</p>
<pre><code class="language-sql">select c.*, c.{parent_field} as parent_id
 from {children} c
where c.{parent_field} = any($parent_ids)
</code></pre>
<p>Data needed to generate:</p>
<ul>
<li>children: name of child table</li>
<li>parent_ids: list of parent ids</li>
<li>parent_field: name of parent field (scalar) in child table</li>
</ul>
<p>The implementation uses a <code>EntityLink::Direct</code> for joins of this type.</p>
<h4><a class="header" href="#type-c" id="type-c">Type C</a></h4>
<p>Use when parent is a list and not derived</p>
<pre><code class="language-sql">select c.*, p.id as parent_id
 from {children} c, {parents} p
where p.id = any($parent_ids)
  and c.id = any(p.{child_field})
</code></pre>
<p>Data needed to generate:</p>
<ul>
<li>children: name of child table</li>
<li>parent_ids: list of parent ids</li>
<li>parents: name of parent table</li>
<li>child_field: name of child field (array) in parent table</li>
</ul>
<p>The implementation uses a <code>EntityLink::Parent</code> for joins of this type.</p>
<h4><a class="header" href="#type-d" id="type-d">Type D</a></h4>
<p>Use when parent is not a list and not derived</p>
<pre><code class="language-sql">select c.*, p.id as parent_id
 from {children} c, {parents} p
where p.id = any($parent_ids)
  and c.id = p.child_field
</code></pre>
<p>Data needed to generate:</p>
<ul>
<li>children: name of child table</li>
<li>parent_ids: list of parent ids</li>
<li>parents: name of parent table</li>
<li>child_field: name of child field (scalar) in parent table</li>
</ul>
<p>The implementation uses a <code>EntityLink::Parent</code> for joins of this type.</p>
<h3><a class="header" href="#putting-it-all-together" id="putting-it-all-together">Putting it all together</a></h3>
<p>Note that in all of these queries, we ultimately return the typename of
each entity, together with a JSONB representation of that entity. We do
this for two reasons: first, because different child tables might have
different schemas, which precludes us from taking the union of these child
tables, and second, because Diesel does not let us execute queries where
the type and number of columns in the result is determined dynamically.</p>
<p>We need to to be careful though to not convert to JSONB too early, as that
is slow when done for large numbers of rows. Deferring conversion is
responsible for some of the complexity in these queries.</p>
<p>In the following, we only go through the queries for relational storage;
for JSONB storage, there are similar considerations, though they are
somewhat simpler as the <code>union all</code> in the below queries turns into
an <code>entity = any(..)</code> clause with JSONB storage, and because we do not need
to convert to JSONB data.</p>
<p>Note that for the windowed queries below, the entity we return will have
<code>parent_id</code> and <code>pos</code> attributes. The <code>parent_id</code> is necessary to attach
the query result to the right parents we already have in memory. The JSONB
queries need to somehow insert the <code>parent_id</code> field into the JSONB data
they return.</p>
<p>In the most general case, we have an <code>EntityCollection::Window</code> with
multiple windows. The query for that case is</p>
<pre><code class="language-sql">with matches as (
  -- Limit the matches for each parent
  select c.*
    from (
      -- Rank matching children for each parent
      select c.*,
             rank() over (partition by c.parent_id order by {query.order}) as pos
        from (
          {window.children_uniform(sort_key, block)}
          union all
            ... range ober all windows) c) c
   where c.pos &gt; {skip} and c.pos &lt;= {skip} + {first})
-- Get the full entity for each match
select m.entity, to_jsonb(c.*) as data, m.parent_id, m.pos
  from matches m, {window.child_table()} c
 where c.vid = m.vid and m.entity = '{window.child_type}'
 union all
       ... range over all windows
 -- Make sure we return the children for each parent in the correct order
 order by parent_id, pos
</code></pre>
<p>When there is only one window, we can simplify the above query. The
simplification basically inlines the <code>matches</code> CTE. That is important as
CTE's in Postgres before Postgres 12 are optimization fences, even when
they are only used once. We therefore reduce the two queries that Postgres
executes above to one for the fairly common case that the children are not
an interface.</p>
<pre><code class="language-sql">select '{window.child_type}' as entity, to_jsonb(c.*) as data
  from (
    -- Rank matching children
    select c.*,
          rank() over (partition by c.parent_id order by {query.order}) as pos
     from ({window.children_detailed()}) c) c
 where c.pos &gt;= {window.skip} and c.pos &lt;= {window.skip} + {window.first}
 order by c.parent_id,c.pos
</code></pre>
<p>When we do not have to window, but only deal with an
<code>EntityCollection::All</code> with multiple entity types, we can simplify the
query by avoiding ranking and just using an ordinary <code>order by</code> clause:</p>
<pre><code class="language-sql">with matches as (
  -- Get uniform info for all matching children
  select '{entity_type}' as entity, id, vid, {sort_key}
    from {entity_table} c
   where {query_filter}
   union all
     ... range over all entity types
   order by {sort_key} offset {query.skip} limit {query.first})
-- Get the full entity for each match
select m.entity, to_jsonb(c.*) as data, c.id, c.{sort_key}
  from matches m, {entity_table} c
 where c.vid = m.vid and m.entity = '{entity_type}'
 union all
       ... range over all entity types
 -- Make sure we return the children for each parent in the correct order
     order by c.{sort_key}, c.id
</code></pre>
<p>And finally, for the very common case of a GraphQL query without nested
children that uses a concrete type, not an interface, we can further
simplify this, again by essentially inlining the <code>matches</code> CTE to:</p>
<pre><code class="language-sql">select '{entity_type}' as entity, to_jsonb(c.*) as data
  from {entity_table} c
 where query.filter()
 order by {query.order} offset {query.skip} limit {query.first}
</code></pre>
<h2><a class="header" href="#boring-list-of-possible-graphql-models" id="boring-list-of-possible-graphql-models">Boring list of possible GraphQL models</a></h2>
<p>These are the eight ways in which a parent/child relationship can be
modeled. For brevity, I left the <code>id</code> attribute on each parent and child
type out.</p>
<p>This list assumes that parent and child types are concrete types, i.e.,
that any interfaces involved in this query have already been reolved into
their implementations and we are dealing with one pair of concrete
parent/child types.</p>
<pre><code class="language-graphql"># Case 1
type Parent {
  children: [Child] @derived
}

type Child {
  parents: [Parent]
}

# Case 2
type Parent {
  child: Child @derived
}

type Child {
  parents: [Parent]
}

# Case 3
type Parent {
  children: [Child] @derived
}

type Child {
  parent: Parent
}

# Case 4
type Parent {
  child: Child @derived
}

type Child {
  parent: Parent
}

# Case 5
type Parent {
  children: [Child]
}

type Child {
  # doesn't matter
}

# Case 6
type Parent {
  children: [Child]
}

type Child {
  # doesn't matter
}

# Case 7
type Parent {
  child: Child
}

type Child {
  # doesn't matter
}

# Case 8
type Parent {
  child: Child
}

type Child {
  # doesn't matter
}
</code></pre>
<h1><a class="header" href="#plan-0003-remove-jsonb-storage" id="plan-0003-remove-jsonb-storage">PLAN-0003: Remove JSONB Storage</a></h1>
<dl>
  <dt>Author</dt>
  <dd>David Lutterkort</dd>
<dt>Implements</dt>
  <dd>No RFC - no user visible changes</dd>
<dt>Engineering Plan pull request</dt>
  <dd><a href="https://github.com/graphprotocol/rfcs/pull/7">https://github.com/graphprotocol/rfcs/pull/7</a></dd>
<dt>Date of submission</dt>
  <dd>2019-12-18</dd>
<dt>Date of approval</dt>
  <dd>2019-12-20</dd>
<dt>Approved by</dt>
  <dd>Jess Ngo, Jannis Pohlmann</dd>
</dl>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>Remove JSONB storage from <code>graph-node</code>. That means that we want to remove
the old storage scheme, and only use relational storage going
forward. At a high level, removal has to touch the following areas:</p>
<ul>
<li>user subgraphs in the hosted service</li>
<li>user subgraphs in self-hosted <code>graph-node</code> instances</li>
<li>subgraph metadata in <code>subgraphs.entities</code> (see <a href="https://github.com/graphprotocol/graph-node/issues/1394">this issue</a>)</li>
<li>the <code>graph-node</code> code base</li>
</ul>
<p>Because it touches so many areas and different things, JSONB storage
removal will need to happen in several steps, the last being actual removal
of JSONB code. The first three steps above are independent of each other
and can be done in parallel.</p>
<h2><a class="header" href="#implementation" id="implementation">Implementation</a></h2>
<h3><a class="header" href="#user-subgraphs-in-the-hosted-service" id="user-subgraphs-in-the-hosted-service">User Subgraphs in the Hosted Service</a></h3>
<p>We will need to communicate to users that they need to update their
subgraphs if they still use JSONB storage. Currently, there are ~ 580
subgraphs
(<a href="https://gist.github.com/lutter/2e7a7716b70b4144fe0b6a5f1c9066bc">list</a>)
belonging to 220 different organizations using JSONB storage. It is quite
likely that the vast majority of them is not needed anymore and simply left
over from somebody trying something out.</p>
<p>We should contact users and tell them that we will delete their subgraph
after a certain date (say 2020-02-01) <em>unless</em> they deploy a new version of
the subgraph (with an explanation why etc. of course) Redeploying their
subgraph is all that is needed for those updates.</p>
<h3><a class="header" href="#self-hosted-user-subgraphs" id="self-hosted-user-subgraphs">Self-hosted User Subgraphs</a></h3>
<p>We will need to tell users that the 'old' JSONB storage is deprecated and
support for it will be removed as of some target date, and that they need
to redeploy their subgraph.</p>
<p>Users will need some documentation/tooling to help them understand</p>
<ul>
<li>which of their deployed subgraphs still use JSONB storage</li>
<li>how to remove old subgraphs</li>
<li>how to remove old deployments</li>
</ul>
<h3><a class="header" href="#subgraph-metadata-in-subgraphsentities" id="subgraph-metadata-in-subgraphsentities">Subgraph Metadata in <code>subgraphs.entities</code></a></h3>
<p>We can treat the <code>subgraphs</code> schema like a normal subgraph, with the
exception that some entities must not be versioned. For that, we will need
to adopt code that makes it possible to write entities to the store without
recording their version (or, more generally, so that there will only be one
version of the entity, tagged with a block range <code>[0,)</code>)</p>
<p>We will manually create the DDL for the <code>subgraphs.graphql</code> schema and run
that as part of a database migration. In that migration, we will also copy
the existing metadata from <code>subgraphs.entities</code> and
<code>subgraphs.entity_history</code> into their new tables.</p>
<h3><a class="header" href="#the-code-base" id="the-code-base">The Code Base</a></h3>
<p>Delete all code handling JSONB storage. This will mostly affect
<code>entities.rs</code> and <code>jsonb_queries.rs</code> in <code>graph-store-postgres</code>, but there
are also smaller things like that we do not need the annotations on
<code>Entity</code> to serialize them to the JSON format that JSONB uses.</p>
<h2><a class="header" href="#tests" id="tests">Tests</a></h2>
<p>Most of the code-level changes are covered by the existing test suite. The
major exception is that the migration of subgraph metadata needs to be
tested and checked manually, using a recent dump of the production
database.</p>
<h2><a class="header" href="#migration" id="migration">Migration</a></h2>
<p>See above on migrating data in the <code>subgraphs</code> schema.</p>
<h2><a class="header" href="#documentation" id="documentation">Documentation</a></h2>
<p>No user-facing documentation is needed.</p>
<h2><a class="header" href="#implementation-plan" id="implementation-plan">Implementation Plan</a></h2>
<p><em>No estimates yet as we should first agree on this general course of
action</em></p>
<ul>
<li>Notify hosted users to update their subgraph or have it deleted by date X</li>
<li>Mark JSONB storage as deprecated and announce when it will be removed</li>
<li>Provide tool to ship with <code>graph-node</code> to delete unused deployments and
unneeded subgraphs</li>
<li>Add affordance to not version entities to relational storage code</li>
<li>Write SQL migrations to create new subgraph metadata schema and copy
existing data</li>
<li>Delete old JSONB code</li>
<li>On start of <code>graph-node</code>, add check for any deployments that still use
JSONB storage and log warning messages telling users to redeploy (once
the JSONB code has been deleted, this data can not be accessed any more)</li>
</ul>
<h2><a class="header" href="#open-questions-1" id="open-questions-1">Open Questions</a></h2>
<p>None</p>
<h1><a class="header" href="#obsolete-engineering-plans" id="obsolete-engineering-plans">Obsolete Engineering Plans</a></h1>
<p>Obsolete Engineering Plans are moved to the <code>engineering-plans/obsolete</code>
directory in the <code>rfcs</code> repository. They are listed below for reference.</p>
<ul>
<li>No Engineering Plans have been obsoleted yet.</li>
</ul>
<h1><a class="header" href="#rejected-engineering-plans" id="rejected-engineering-plans">Rejected Engineering Plans</a></h1>
<p>Rejected Engineering Plans can be found by filtering open and closed pull
requests by those that are labeled with <code>rejected</code>. This list can be <a href="https://github.com/graphprotocol/rfcs/issues?q=label:engineering-plan+label:rejected">found
here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="assets/mermaid.min.js"></script>
        
        <script type="text/javascript" src="assets/mermaid-init.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
